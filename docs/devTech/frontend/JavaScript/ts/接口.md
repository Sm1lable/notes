# 接口

接口的作用是约束一个参数的类型。它会检查对象是否**满足（而不是吻合）**接口的“形状”，

```ts
interface Labelized {
    label: string
}


function foo(labelized: Labelized) {
    console.log(labelized.label) //ok
    console.log(labelized.value) // error，类型Labelized上不存在value属性（无法推断出来有value属性），强制通过编译的js代码可以运行
} 

foo({label: 'bar'}) // ok

```


## 可选参数

可选参数表明接口中的一些属性可以是不存在的，只是在有些条件下可能存在。在类型推导上有很强大的功能

```ts
interface P {
    x?: number,
    y?: number
}

function foo(p: P) {
    let res = 0
    res += p.x ?? 0
    res += p.y ?? 0
    return res
}

foo({x: 10, y: 20})
```

## 只读属性

可以使用`readonly`关键字来限制属性只读

```ts
interface P {
    readonly x: number,
    y: number
}

const p: P = {x: 10, y: 20}
p.y = 30 // ok
p.x = 20 // error
```

ts也提供了`ReadonlyArray<T>`类型用于限制数组属性只读，限制了所有可变方法

```ts
let arr: ReadonlyArray<number> = [1, 2, 3]

arr.push(4) // error
arr[1] = 5 // error
arr.length = 4 // error
arr = [1, 2, 4] // error
```

## 额外属性检查

ts在检查函数参数时会对对象字面量做额外的检查

```ts
interface P {
    x: number,
    y: number
}

const p = {x: 10, y: 10, z: 10}

function foo(p: P) {
    return p
}

foo(p) //ok
foo({x: 10, y: 10, z: 10}) // Object literal may only specify known properties, and 'z' does not exist in type 'P'
```



## 函数类型

接口可以直接用于描述函数的类型

```ts
interface Func {
    (a: number, b: number): number
}

let func: Func = function(a: number, b: number): number {
    return isNaN(a + b) ? a + b : 0
}
```

也可以不用显式指定函数参数和返回值类型，ts会推断函数的参数和返回值是否满足接口定义的要求

```ts
let func: Func = function(a, b) {
    return !isNaN(a + b) ? a + b : 0
}
```

## 可索引类型

可索引类型描述了可以通过下标索引取值的类型，比如数组和字符串。
ts支持两种索引类型：string和number

```ts
interface StringArray {
    [index: number]: string
}

let arr: AnyArray = ['a', 'b']
let str: string = arr[0]
```

可以同时使用string和number作为索引，但是数字索引的类型必须是字符串索引得到类型的子类型，因为本质上number在进行索引时也会转为字符串进行索引，
**这也意味着就算仅仅使用number进行索引不能调用，因为其没有实现对应的原型继承**

```ts
class Animal {
    name: string;
}
class Dog extends Animal {
    breed: string;
}

interface NotOkay {
    [x: number]: Dog;
    [x: string]: Number;
}
```

实际上索引签名相当于将对象描述成一个字典








